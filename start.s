.extern kernel_main # Мы объявляем метку 'kernel_main' внешней по отношению к этому файлу. # Это потому, что это имя основной функции C в 'kernel.c'. 
.global start 		# Мы объявляем метку 'start' как глобальную (доступную из-за пределов этого файла), поскольку компоновщику необходимо знать, где она находится. # Чуть позже мы взглянем на код, определяющий эту метку. 

# Нашему загрузчику GRUB необходимо знать некоторую базовую информацию о нашем ядре, прежде чем он сможет его загрузить. # Мы передаем GRUB эту информацию, используя стандарт, известный как «мультизагрузка». # Чтобы определить действительный «заголовок мультизагрузки», который будет распознан GRUB, нам нужно жестко запрограммировать некоторые# константы в исполняемый файл. Следующий код вычисляет эти константы. 
.set MB_MAGIC, 0x1BADB002 # Это «магическая» константа, которую GRUB будет использовать для определения местоположения нашего ядра. 
.set MB_FLAGS, (1 << 0) | (1 << 1) # Это говорит GRUB 1: загружать модули на границах страницы и 2: предоставлять карту памяти (это полезно позже в разработке) # Наконец, мы вычисляем контрольную сумму, которая включает все предыдущие значения 
.set MB_CHECKSUM, (0 - (MB_MAGIC + MB_FLAGS)) 

# Теперь мы запускаем раздел исполняемого файла, который будет содержать наш заголовок Multiboot 
.section .multiboot 
	.align 4 # Убедитесь, что следующие данные выровнены по кратному 4 байтам 
	# Использовать ранее вычисленные константы в исполняемом коде
	.long MB_MAGIC 
	.long MB_FLAGS 
# Используйте контрольную сумму, которую мы вычислили ранее 
	.long MB_CHECKSUM 

 # Этот раздел содержит данные, инициализированные нулями при загрузке ядра 
.section .bss 
# Нашему C-коду для работы потребуется стек. Здесь мы выделяем 4096 байт (или 4 килобайта) для нашего стека. 
# Мы можем расширить это позже, если нам нужен больший стек. Пока этого будет вполне достаточно. 
	.align 16 
	stack_bottom: 
		.skip 4096# Зарезервировать стек размером 4096 байт (4 КБ) 
	stack_top: 

 # Этот раздел содержит наш фактический ассемблерный код, который будет запускаться при загрузке нашего ядра 
.section .text
# Вот метка «начало», о которой мы упоминали ранее. Это первый код, который запускается в нашем ядре. 
	start: 
	# Прежде всего: мы хотим настроить среду, готовую для запуска C-кода. 
	# C очень нетребователен к своим требованиям: все, что нам нужно сделать, это настроить стек. 
	# Обратите внимание, что на x86 стек растет ВНИЗ. Вот почему мы начинаем сверху. 
		mov $stack_top, %esp # Устанавливаем указатель стека на вершину стека 
 
	# Теперь у нас есть C-достойная (ха-ха!) среда, готовая для запуска остальной части нашего ядра. 
	# Теперь мы можем вызвать нашу основную функцию C. 
		call kernel_main 
 
	# Если по каким-то загадочным обстоятельствам код ядра C когда-либо вернется, все, что мы хотим сделать, это повесить ЦП
		hang: 
			cli # Отключить прерывания ЦП 
			hlt # Остановить 
			# зависание ЦП jmp# Если это не сработало, выполните цикл и повторите попытку.
